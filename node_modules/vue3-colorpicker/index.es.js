var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { defineComponent, ref, reactive, watch, computed, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, pushScopeId, popScopeId, Fragment, renderList, getCurrentInstance, createCommentVNode, resolveComponent, createBlock, createVNode, inject, withDirectives, vShow, toDisplayString, renderSlot, provide, withCtx, resolveDynamicComponent, mergeProps, Teleport } from "vue";
import propTypes from "vue-types";
import tinycolor from "tinycolor2";
import { tryOnMounted, whenever, useLocalStorage, useDebounceFn, onClickOutside } from "@vueuse/core";
import { DOMUtils } from "@aesoper/normal-utils";
import { merge } from "lodash-es";
import { Angle } from "vue3-angle";
import "vue3-angle/style.css";
import { createPopper } from "@popperjs/core";
import { stringify, parse } from "gradient-parser";
var index = "";
const double = (num) => {
  return Math.round(num * 100) / 100;
};
class Color {
  constructor(input) {
    __publicField(this, "instance");
    __publicField(this, "alphaValue", 0);
    __publicField(this, "redValue", 0);
    __publicField(this, "greenValue", 0);
    __publicField(this, "blueValue", 0);
    __publicField(this, "hueValue", 0);
    __publicField(this, "saturationValue", 0);
    __publicField(this, "brightnessValue", 0);
    __publicField(this, "hslSaturationValue", 0);
    __publicField(this, "lightnessValue", 0);
    __publicField(this, "initAlpha", () => {
      const initAlpha = this.instance.getAlpha();
      this.alphaValue = Math.min(1, initAlpha) * 100;
    });
    __publicField(this, "initLightness", () => {
      const { s, l } = this.instance.toHsl();
      this.hslSaturationValue = double(s);
      this.lightnessValue = double(l);
    });
    __publicField(this, "initRgb", () => {
      const { r, g, b } = this.instance.toRgb();
      this.redValue = double(r);
      this.greenValue = double(g);
      this.blueValue = double(b);
    });
    __publicField(this, "initHsb", () => {
      const { h, s, v } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(h));
      this.saturationValue = double(s);
      this.brightnessValue = double(v);
    });
    __publicField(this, "toHexString", () => {
      return this.instance.toHexString();
    });
    __publicField(this, "toRgbString", () => {
      return this.instance.toRgbString();
    });
    this.instance = tinycolor(input);
    this.initRgb();
    this.initHsb();
    this.initLightness();
    this.initAlpha();
  }
  toString(format) {
    return this.instance.toString(format);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(hexString) {
    this.instance = tinycolor(hexString);
    this.initHsb();
    this.initRgb();
    this.initAlpha();
    this.initLightness();
  }
  set hue(value) {
    if (this.saturation === 0 && this.brightness === 0) {
      this.saturationValue = 1;
      this.brightnessValue = 1;
    }
    this.instance = tinycolor({
      h: double(value),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.hueValue = double(value);
  }
  get hue() {
    return this.hueValue;
  }
  set saturation(value) {
    this.instance = tinycolor({
      h: this.hue,
      s: double(value),
      v: this.brightness,
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.saturationValue = double(value);
  }
  get saturation() {
    return this.saturationValue;
  }
  set brightness(value) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.saturation,
      v: double(value),
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.brightnessValue = double(value);
  }
  get brightness() {
    return this.brightnessValue;
  }
  set lightness(value) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.hslSaturationValue,
      l: double(value),
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initHsb();
    this.lightnessValue = double(value);
  }
  get lightness() {
    return this.lightnessValue;
  }
  set red(value) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      r: double(value),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.redValue = double(value);
  }
  get red() {
    return this.redValue;
  }
  set green(value) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      g: double(value),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.greenValue = double(value);
  }
  get green() {
    return this.greenValue;
  }
  set blue(value) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      b: double(value),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.blueValue = double(value);
  }
  get blue() {
    return this.blueValue;
  }
  set alpha(value) {
    this.instance.setAlpha(value / 100);
    this.alphaValue = value;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, this.alpha / 100];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, this.alpha / 100];
  }
  get HSL() {
    return [this.hue, this.hslSaturationValue, this.lightness, this.alpha / 100];
  }
}
function rgbaColor(r, g, b, a) {
  return `rgba(${[r, g, b, a / 100].join(",")})`;
}
const clamp = (value, min, max) => {
  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
};
const HistoryColorKey = "color-history";
const MAX_STORAGE_LENGTH = 8;
var Alpha_vue_vue_type_style_index_0_scoped_true_lang = "";
var _export_sfc = (sfc, props) => {
  for (const [key, val] of props) {
    sfc[key] = val;
  }
  return sfc;
};
const _sfc_main$b = defineComponent({
  name: "Alpha",
  props: {
    color: propTypes.instanceOf(Color),
    size: propTypes.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props, { emit }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props.color || new Color();
    const state = reactive({
      red: color.red,
      green: color.green,
      blue: color.blue,
      alpha: color.alpha
    });
    watch(() => props.color, (value) => {
      if (value) {
        color = value;
        merge(state, {
          red: value.red,
          green: value.green,
          blue: value.blue,
          alpha: value.alpha
        });
      }
    }, { deep: true });
    const getBackgroundStyle = computed(() => {
      const startColor = rgbaColor(state.red, state.green, state.blue, 0);
      const endColor = rgbaColor(state.red, state.green, state.blue, 100);
      return {
        background: `linear-gradient(to right, ${startColor} , ${endColor})`
      };
    });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const alpha = state.alpha / 100;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left = getCursorLeft();
      return {
        left: left + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left = event.clientX - rect.left;
        left = Math.max(offsetWidth / 2, left);
        left = Math.min(left, rect.width - offsetWidth / 2);
        const alpha = Math.round((left - offsetWidth / 2) / (rect.width - offsetWidth) * 100);
        color.alpha = alpha;
        state.alpha = alpha;
        emit("change", alpha);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        DOMUtils.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
  }
});
const _withScopeId$5 = (n) => (pushScopeId("data-v-18925ba6"), n = n(), popScopeId(), n);
const _hoisted_1$a = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
const _hoisted_2$a = [
  _hoisted_1$a
];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle(_ctx.getBackgroundStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$a, 6)
    ], 4)
  ], 2);
}
var Alpha = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-18925ba6"]]);
var Palette_vue_vue_type_style_index_0_scoped_true_lang = "";
const defaultColors = [
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
];
const _sfc_main$a = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(_props, { emit }) {
    const computedBgStyle = (color) => {
      if (color === "transparent") {
        return color;
      }
      if (color === "advance") {
        return {};
      }
      return { background: tinycolor(color).toRgbString() };
    };
    const onColorChange = (color) => {
      emit("change", color);
    };
    return { palettes: defaultColors, computedBgStyle, onColorChange };
  }
});
const _hoisted_1$9 = { class: "vc-compact" };
const _hoisted_2$9 = ["onClick"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palettes, (v, i) => {
      return openBlock(), createElementBlock("div", {
        key: i,
        class: "vc-compact__row"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(v, (v1, k) => {
          return openBlock(), createElementBlock("div", {
            key: k,
            class: "vc-compact__color-cube--wrap",
            onClick: ($event) => _ctx.onColorChange(v1)
          }, [
            createElementVNode("div", {
              class: normalizeClass([
                "vc-compact__color_cube",
                {
                  advance: v1 === "advance",
                  transparent: v1 === "transparent"
                }
              ]),
              style: normalizeStyle(_ctx.computedBgStyle(v1))
            }, null, 6)
          ], 8, _hoisted_2$9);
        }), 128))
      ]);
    }), 128))
  ]);
}
var Palette = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-b969fd48"]]);
var Board_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$9 = defineComponent({
  name: "Board",
  props: {
    color: propTypes.instanceOf(Color),
    round: propTypes.bool.def(false),
    hide: propTypes.bool.def(true)
  },
  emits: ["change"],
  setup(props, { emit }) {
    var _a, _b, _c;
    const instance = getCurrentInstance();
    const hueHsv = {
      h: ((_a = props.color) == null ? void 0 : _a.hue) || 0,
      s: 1,
      v: 1
    };
    const hueColor = new Color(hueHsv).toHexString();
    const state = reactive({
      hueColor,
      saturation: ((_b = props.color) == null ? void 0 : _b.saturation) || 0,
      brightness: ((_c = props.color) == null ? void 0 : _c.brightness) || 0
    });
    const cursorTop = ref(0);
    const cursorLeft = ref(0);
    const cursorElement = ref();
    const boardElement = ref();
    const getCursorStyle = computed(() => {
      return {
        top: cursorTop.value + "px",
        left: cursorLeft.value + "px"
      };
    });
    const updatePosition = () => {
      if (instance) {
        const el = instance.vnode.el;
        cursorLeft.value = state.saturation * (el == null ? void 0 : el.clientWidth);
        cursorTop.value = (1 - state.brightness) * (el == null ? void 0 : el.clientHeight);
      }
    };
    const onClickBoard = (event) => {
      const target = event.target;
      if (target !== boardElement.value) {
        handleDrag(event);
      }
    };
    const handleDrag = (event) => {
      if (instance) {
        const el = instance.vnode.el;
        const rect = el == null ? void 0 : el.getBoundingClientRect();
        let left = event.clientX - rect.left;
        let top = event.clientY - rect.top;
        left = clamp(left, 0, rect.width);
        top = clamp(top, 0, rect.height);
        const saturation = left / rect.width;
        const bright = clamp(-(top / rect.height) + 1, 0, 1);
        cursorLeft.value = left;
        cursorTop.value = top;
        state.saturation = saturation;
        state.brightness = bright;
        emit("change", saturation, bright);
      }
    };
    tryOnMounted(() => {
      if (instance && instance.vnode.el && cursorElement.value) {
        DOMUtils.triggerDragEvent(cursorElement.value, {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        });
        updatePosition();
      }
    });
    whenever(() => props.color, (value) => {
      merge(state, {
        hueColor: new Color({ h: value.hue, s: 1, v: 1 }).toHexString(),
        saturation: value.saturation,
        brightness: value.brightness
      });
      updatePosition();
    }, { deep: true });
    return { state, cursorElement, getCursorStyle, onClickBoard };
  }
});
const _withScopeId$4 = (n) => (pushScopeId("data-v-63803390"), n = n(), popScopeId(), n);
const _hoisted_1$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__white" }, null, -1));
const _hoisted_2$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__black" }, null, -1));
const _hoisted_3$6 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", null, null, -1));
const _hoisted_4$5 = [
  _hoisted_3$6
];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": _ctx.round, "vc-saturation__hidden": _ctx.hide }]),
    style: normalizeStyle({ backgroundColor: _ctx.state.hueColor }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickBoard && _ctx.onClickBoard(...args))
  }, [
    _hoisted_1$8,
    _hoisted_2$8,
    createElementVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle(_ctx.getCursorStyle)
    }, _hoisted_4$5, 4)
  ], 6);
}
var Board = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-63803390"]]);
var Hue_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$8 = defineComponent({
  name: "Hue",
  props: {
    color: propTypes.instanceOf(Color),
    size: propTypes.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props, { emit }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props.color || new Color();
    const state = reactive({
      hue: color.hue || 0
    });
    watch(() => props.color, (value) => {
      if (value) {
        color = value;
        merge(state, { hue: color.hue });
      }
    }, { deep: true });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        if (state.hue === 360) {
          return rect.width - offsetWidth / 2;
        }
        return state.hue % 360 * (rect.width - offsetWidth) / 360 + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left = getCursorLeft();
      return {
        left: left + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left = event.clientX - rect.left;
        left = Math.min(left, rect.width - offsetWidth / 2);
        left = Math.max(offsetWidth / 2, left);
        const hue = Math.round((left - offsetWidth / 2) / (rect.width - offsetWidth) * 360);
        color.hue = hue;
        state.hue = hue;
        emit("change", hue);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        DOMUtils.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, onClickSider };
  }
});
const _withScopeId$3 = (n) => (pushScopeId("data-v-5c4cae5b"), n = n(), popScopeId(), n);
const _hoisted_1$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
const _hoisted_2$7 = [
  _hoisted_1$7
];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$7, 6)
    ], 512)
  ], 2);
}
var Hue = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-5c4cae5b"]]);
var Lightness_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$7 = defineComponent({
  name: "Lightness",
  props: {
    color: propTypes.instanceOf(Color),
    size: propTypes.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props, { emit }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props.color || new Color();
    const [h, s, l] = color.HSL;
    const state = reactive({
      hue: h,
      saturation: s,
      lightness: l
    });
    watch(() => props.color, (value) => {
      if (value) {
        color = value;
        const [hue, saturation, lightness] = color.HSL;
        merge(state, {
          hue,
          saturation,
          lightness
        });
      }
    }, { deep: true });
    const getBackgroundStyle = computed(() => {
      const color1 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.8
      }).toPercentageRgbString();
      const color2 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.6
      }).toPercentageRgbString();
      const color3 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.4
      }).toPercentageRgbString();
      const color4 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`
        ]
      };
    });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const lightness = state.lightness;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return (1 - lightness) * (rect.width - offsetWidth) + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left = getCursorLeft();
      return {
        left: left + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left = event.clientX - rect.left;
        left = Math.max(offsetWidth / 2, left);
        left = Math.min(left, rect.width - offsetWidth / 2);
        const light = 1 - (left - offsetWidth / 2) / (rect.width - offsetWidth);
        color.lightness = light;
        emit("change", light);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        DOMUtils.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
  }
});
const _withScopeId$2 = (n) => (pushScopeId("data-v-6156acb7"), n = n(), popScopeId(), n);
const _hoisted_1$6 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
const _hoisted_2$6 = [
  _hoisted_1$6
];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle(_ctx.getBackgroundStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$6, 6)
    ], 4)
  ], 2);
}
var Lightness = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-6156acb7"]]);
var History_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$6 = defineComponent({
  name: "History",
  props: {
    colors: propTypes.arrayOf(String).def(() => []),
    round: propTypes.bool.def(false)
  },
  emits: ["change"],
  setup(_props, { emit }) {
    const onColorSelect = (v) => {
      emit("change", v);
    };
    return { onColorSelect };
  }
});
const _hoisted_1$5 = {
  key: 0,
  class: "vc-colorPicker__record"
};
const _hoisted_2$5 = { class: "color-list" };
const _hoisted_3$5 = ["onClick"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.colors && _ctx.colors.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
    createElementVNode("div", _hoisted_2$5, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colors, (v, i) => {
        return openBlock(), createElementBlock("div", {
          key: i,
          class: normalizeClass(["color-item", "transparent", { "color-item__round": _ctx.round }]),
          onClick: ($event) => _ctx.onColorSelect(v)
        }, [
          createElementVNode("div", {
            class: "color-item__display",
            style: normalizeStyle({ backgroundColor: v })
          }, null, 4)
        ], 10, _hoisted_3$5);
      }), 128))
    ])
  ])) : createCommentVNode("", true);
}
var History = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-7e6b67ca"]]);
var Display_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$5 = defineComponent({
  name: "Display",
  props: {
    color: propTypes.instanceOf(Color),
    disableAlpha: propTypes.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(props, { emit }) {
    var _a, _b, _c;
    const state = reactive({
      color: props.color,
      previewBgColor: (_a = props.color) == null ? void 0 : _a.toRgbString(),
      alpha: ((_b = props.color) == null ? void 0 : _b.alpha) || 100,
      hex: (_c = props.color) == null ? void 0 : _c.hex
    });
    const getBgColorStyle = computed(() => {
      return {
        background: state.previewBgColor
      };
    });
    const onAlphaBlur = (evt) => {
      const target = evt.target;
      const opacity = parseInt(target.value.replace("%", ""));
      if (!isNaN(opacity) && state.color) {
        state.alpha = opacity;
        state.color.alpha = opacity;
      }
    };
    const onInputChange = (event) => {
      const target = event.target;
      const hex = target.value.replace("#", "");
      if (tinycolor(hex).isValid() && state.color) {
        state.color.hex = hex;
      }
    };
    whenever(() => props.color, (value) => {
      if (value) {
        state.color = value;
      }
    }, { deep: true });
    whenever(() => state.color, () => {
      if (state.color) {
        state.previewBgColor = state.color.toRgbString();
        state.alpha = state.color.alpha;
        state.hex = state.color.hex;
        emit("update:color", state.color);
        emit("change", state.color);
      }
    }, { deep: true });
    return { state, getBgColorStyle, onAlphaBlur, onInputChange };
  }
});
const _hoisted_1$4 = { class: "vc-display" };
const _hoisted_2$4 = { class: "vc-current-color vc-transparent" };
const _hoisted_3$4 = { class: "vc-color-input" };
const _hoisted_4$4 = ["value"];
const _hoisted_5$4 = {
  key: 0,
  class: "vc-alpha-input"
};
const _hoisted_6$2 = ["value"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createElementVNode("div", _hoisted_2$4, [
      createElementVNode("div", {
        class: "color-cube",
        style: normalizeStyle(_ctx.getBgColorStyle)
      }, null, 4)
    ]),
    createElementVNode("div", _hoisted_3$4, [
      createElementVNode("input", {
        value: _ctx.state.hex,
        onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onInputChange && _ctx.onInputChange(...args))
      }, null, 40, _hoisted_4$4)
    ]),
    !_ctx.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_5$4, [
      createElementVNode("input", {
        class: "vc-alpha-input__inner",
        value: _ctx.state.alpha + "%",
        onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onAlphaBlur && _ctx.onAlphaBlur(...args))
      }, null, 40, _hoisted_6$2)
    ])) : createCommentVNode("", true)
  ]);
}
var Display = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-0067da1d"]]);
var FkColorPicker_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$4 = defineComponent({
  name: "FkColorPicker",
  components: { Display, Alpha, Palette, Board, Hue, Lightness, History },
  props: {
    color: propTypes.instanceOf(Color),
    disableHistory: propTypes.bool.def(false),
    roundHistory: propTypes.bool.def(false),
    disableAlpha: propTypes.bool.def(false)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(props, { emit }) {
    const colorInstance = props.color || new Color();
    const state = reactive({
      color: colorInstance,
      hex: colorInstance.toHexString(),
      rgb: colorInstance.toRgbString()
    });
    const advancePanelShow = ref(false);
    const previewStyle = computed(() => {
      return { background: state.rgb };
    });
    const onBack = () => {
      advancePanelShow.value = false;
      emit("advanceChange", false);
    };
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props.disableHistory) {
        return;
      }
      const rgbString = state.color.toRgbString();
      historyColors.value = historyColors.value.filter((value) => {
        return !tinycolor.equals(value, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    const onCompactChange = (color) => {
      if (color === "advance") {
        advancePanelShow.value = true;
        emit("advanceChange", true);
      } else {
        state.color.hex = color;
        emit("advanceChange", false);
      }
    };
    const onAlphaChange = (alpha) => {
      state.color.alpha = alpha;
    };
    const onHueChange = (hue) => {
      state.color.hue = hue;
    };
    const onBoardChange = (saturation, brightness) => {
      state.color.saturation = saturation;
      state.color.brightness = brightness;
    };
    const onLightChange = (light) => {
      state.color.lightness = light;
    };
    const onInputChange = (event) => {
      const target = event.target;
      const hex = target.value.replace("#", "");
      if (tinycolor(hex).isValid()) {
        state.color.hex = hex;
      }
    };
    whenever(() => props.color, (value) => {
      if (value) {
        state.color = value;
      }
    }, { deep: true });
    whenever(() => state.color, () => {
      state.hex = state.color.hex;
      state.rgb = state.color.toRgbString();
      updateColorHistoryFn();
      emit("update:color", state.color);
      emit("change", state.color);
    }, { deep: true });
    return {
      state,
      advancePanelShow,
      onBack,
      onCompactChange,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onLightChange,
      onInputChange,
      previewStyle,
      historyColors
    };
  }
});
const _withScopeId$1 = (n) => (pushScopeId("data-v-592a5ec3"), n = n(), popScopeId(), n);
const _hoisted_1$3 = { class: "vc-fk-colorPicker" };
const _hoisted_2$3 = { class: "vc-fk-colorPicker__inner" };
const _hoisted_3$3 = { class: "vc-fk-colorPicker__header" };
const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
const _hoisted_5$3 = [
  _hoisted_4$3
];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Palette = resolveComponent("Palette");
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Lightness = resolveComponent("Lightness");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createElementVNode("div", _hoisted_2$3, [
      createElementVNode("div", _hoisted_3$3, [
        _ctx.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { "cursor": "pointer" },
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
        }, _hoisted_5$3)) : createCommentVNode("", true)
      ]),
      !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
        key: 0,
        onChange: _ctx.onCompactChange
      }, null, 8, ["onChange"])) : createCommentVNode("", true),
      _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
        key: 1,
        color: _ctx.state.color,
        onChange: _ctx.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
        key: 2,
        color: _ctx.state.color,
        onChange: _ctx.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
        key: 3,
        color: _ctx.state.color,
        onChange: _ctx.onLightChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
        key: 4,
        color: _ctx.state.color,
        onChange: _ctx.onAlphaChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      createVNode(_component_Display, {
        color: _ctx.state.color,
        "disable-alpha": _ctx.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
        key: 5,
        round: _ctx.roundHistory,
        colors: _ctx.historyColors,
        onChange: _ctx.onCompactChange
      }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
    ])
  ]);
}
var FkColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-592a5ec3"]]);
var ChromeColorPicker_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$3 = defineComponent({
  name: "ChromeColorPicker",
  components: { Display, Alpha, Board, Hue, History },
  props: {
    color: propTypes.instanceOf(Color),
    disableHistory: propTypes.bool.def(false),
    roundHistory: propTypes.bool.def(false),
    disableAlpha: propTypes.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(props, { emit }) {
    const colorInstance = props.color || new Color();
    const state = reactive({
      color: colorInstance,
      hex: colorInstance.toHexString(),
      rgb: colorInstance.toRgbString()
    });
    const previewStyle = computed(() => {
      return { background: state.rgb };
    });
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props.disableHistory) {
        return;
      }
      const rgbString = state.color.toRgbString();
      historyColors.value = historyColors.value.filter((value) => {
        return !tinycolor.equals(value, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    const onAlphaChange = (alpha) => {
      state.color.alpha = alpha;
    };
    const onHueChange = (hue) => {
      state.color.hue = hue;
    };
    const onBoardChange = (saturation, brightness) => {
      state.color.saturation = saturation;
      state.color.brightness = brightness;
    };
    const onCompactChange = (color) => {
      if (color !== "advance") {
        state.color.hex = color;
      }
    };
    whenever(() => props.color, (value) => {
      if (value) {
        state.color = value;
      }
    }, { deep: true });
    whenever(() => state.color, () => {
      state.hex = state.color.hex;
      state.rgb = state.color.toRgbString();
      updateColorHistoryFn();
      emit("update:color", state.color);
      emit("change", state.color);
    }, { deep: true });
    return {
      state,
      previewStyle,
      historyColors,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onCompactChange
    };
  }
});
const _hoisted_1$2 = { class: "vc-chrome-colorPicker" };
const _hoisted_2$2 = { class: "vc-chrome-colorPicker-body" };
const _hoisted_3$2 = { class: "chrome-controls" };
const _hoisted_4$2 = { class: "chrome-color-wrap transparent" };
const _hoisted_5$2 = { class: "chrome-sliders" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    createVNode(_component_Board, {
      round: true,
      hide: false,
      color: _ctx.state.color,
      onChange: _ctx.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createElementVNode("div", _hoisted_2$2, [
      createElementVNode("div", _hoisted_3$2, [
        createElementVNode("div", _hoisted_4$2, [
          createElementVNode("div", {
            class: "current-color",
            style: normalizeStyle(_ctx.previewStyle)
          }, null, 4)
        ]),
        createElementVNode("div", _hoisted_5$2, [
          createVNode(_component_Hue, {
            size: "small",
            color: _ctx.state.color,
            onChange: _ctx.onHueChange
          }, null, 8, ["color", "onChange"]),
          !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
            key: 0,
            size: "small",
            color: _ctx.state.color,
            onChange: _ctx.onAlphaChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true)
        ])
      ]),
      createVNode(_component_Display, {
        color: _ctx.state.color,
        "disable-alpha": _ctx.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
        key: 0,
        round: _ctx.roundHistory,
        colors: _ctx.historyColors,
        onChange: _ctx.onCompactChange
      }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
    ])
  ]);
}
var ChromeColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-61d7303b"]]);
const ColorPickerProviderKey = "Vue3ColorPickerProvider";
var GradientColorPicker_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$2 = defineComponent({
  name: "GradientColorPicker",
  components: { Angle, Display, Alpha, Palette, Board, Hue, Lightness, History },
  props: {
    startColor: propTypes.instanceOf(Color).isRequired,
    endColor: propTypes.instanceOf(Color).isRequired,
    startColorStop: propTypes.number.def(0),
    endColorStop: propTypes.number.def(100),
    angle: propTypes.number.def(0),
    disableHistory: propTypes.bool.def(false),
    roundHistory: propTypes.bool.def(false),
    disableAlpha: propTypes.bool.def(false)
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange"
  ],
  setup(props, { emit }) {
    const state = reactive({
      startActive: true,
      startColor: props.startColor,
      endColor: props.endColor,
      startColorStop: props.startColorStop,
      endColorStop: props.endColorStop,
      angle: props.angle,
      startColorRgba: props.startColor.toRgbString(),
      endColorRgba: props.endColor.toRgbString()
    });
    const parent = inject(ColorPickerProviderKey);
    const advancePanelShow = ref(false);
    const startGradientRef = ref();
    const stopGradientRef = ref();
    const colorRangeRef = ref();
    const currentColor = computed({
      get: () => {
        return state.startActive ? state.startColor : state.endColor;
      },
      set: (v) => {
        if (state.startActive) {
          state.startColor = v;
          return;
        }
        state.endColor = v;
      }
    });
    const getStartColorLeft = computed(() => {
      if (colorRangeRef.value && startGradientRef.value) {
        const alpha = state.startColorStop / 100;
        const rect = colorRangeRef.value.getBoundingClientRect();
        const offsetWidth = startGradientRef.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const getEndColorLeft = computed(() => {
      if (colorRangeRef.value && stopGradientRef.value) {
        const alpha = state.endColorStop / 100;
        const rect = colorRangeRef.value.getBoundingClientRect();
        const offsetWidth = stopGradientRef.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const gradientBg = computed(() => {
      return {
        background: `linear-gradient(${state.angle}deg, ${state.startColorRgba} ${state.startColorStop}%, ${state.endColorRgba} ${state.endColorStop}%)`
      };
    });
    const dragStartRange = (evt) => {
      var _a;
      state.startActive = true;
      if (colorRangeRef.value && startGradientRef.value) {
        const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
        let left = evt.clientX - rect.left;
        left = Math.max(startGradientRef.value.offsetWidth / 2, left);
        left = Math.min(left, rect.width - startGradientRef.value.offsetWidth / 2);
        state.startColorStop = Math.round((left - startGradientRef.value.offsetWidth / 2) / (rect.width - startGradientRef.value.offsetWidth) * 100);
        emit("update:startColorStop", state.startColorStop);
        emit("startColorStopChange", state.startColorStop);
      }
    };
    const dragEndRange = (evt) => {
      var _a;
      state.startActive = false;
      if (colorRangeRef.value && stopGradientRef.value) {
        const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
        let left = evt.clientX - rect.left;
        left = Math.max(stopGradientRef.value.offsetWidth / 2, left);
        left = Math.min(left, rect.width - stopGradientRef.value.offsetWidth / 2);
        state.endColorStop = Math.round((left - stopGradientRef.value.offsetWidth / 2) / (rect.width - stopGradientRef.value.offsetWidth) * 100);
        emit("update:endColorStop", state.endColorStop);
        emit("endColorStopChange", state.endColorStop);
      }
    };
    const onDegreeBlur = (evt) => {
      const target = evt.target;
      const degree = parseInt(target.value.replace("\xB0", ""));
      if (!isNaN(degree)) {
        state.angle = degree % 360;
      }
      emit("update:angle", state.angle);
      emit("angleChange", state.angle);
    };
    const onDegreeChange = (angle) => {
      state.angle = angle;
      emit("update:angle", state.angle);
      emit("angleChange", state.angle);
    };
    const onCompactChange = (color) => {
      if (color === "advance") {
        advancePanelShow.value = true;
        emit("advanceChange", true);
      } else {
        currentColor.value.hex = color;
        emit("advanceChange", false);
      }
      doColorChange();
    };
    const onAlphaChange = (alpha) => {
      currentColor.value.alpha = alpha;
      doColorChange();
    };
    const onHueChange = (hue) => {
      currentColor.value.hue = hue;
      doColorChange();
    };
    const onBoardChange = (saturation, brightness) => {
      currentColor.value.saturation = saturation;
      currentColor.value.brightness = brightness;
      doColorChange();
    };
    const onLightChange = (light) => {
      currentColor.value.lightness = light;
      doColorChange();
    };
    const doColorChange = () => {
      if (state.startActive) {
        emit("update:startColor", state.startColor);
        emit("startColorChange", state.startColor);
      } else {
        emit("update:endColor", state.endColor);
        emit("endColorChange", state.endColor);
      }
    };
    const onBack = () => {
      advancePanelShow.value = false;
      emit("advanceChange", false);
    };
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props.disableHistory) {
        return;
      }
      const rgbString = currentColor.value.toRgbString();
      historyColors.value = historyColors.value.filter((value) => {
        return !tinycolor.equals(value, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    tryOnMounted(() => {
      if (stopGradientRef.value && startGradientRef.value) {
        DOMUtils.triggerDragEvent(stopGradientRef.value, {
          drag: (event) => {
            dragEndRange(event);
          },
          end: (event) => {
            dragEndRange(event);
          }
        });
        DOMUtils.triggerDragEvent(startGradientRef.value, {
          drag: (event) => {
            dragStartRange(event);
          },
          end: (event) => {
            dragStartRange(event);
          }
        });
      }
    });
    whenever(() => state.startColor, (value) => {
      state.startColorRgba = value.toRgbString();
    }, { deep: true });
    whenever(() => state.endColor, (value) => {
      state.endColorRgba = value.toRgbString();
    }, { deep: true });
    whenever(() => currentColor.value, () => {
      updateColorHistoryFn();
    }, { deep: true });
    return {
      startGradientRef,
      stopGradientRef,
      colorRangeRef,
      state,
      currentColor,
      getStartColorLeft,
      getEndColorLeft,
      gradientBg,
      advancePanelShow,
      onDegreeBlur,
      onCompactChange,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onLightChange,
      historyColors,
      onBack,
      onDegreeChange,
      lang: parent == null ? void 0 : parent.lang
    };
  }
});
const _withScopeId = (n) => (pushScopeId("data-v-f63daa7a"), n = n(), popScopeId(), n);
const _hoisted_1$1 = { class: "vc-gradient-picker" };
const _hoisted_2$1 = { class: "vc-gradient-picker__header" };
const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
const _hoisted_4$1 = [
  _hoisted_3$1
];
const _hoisted_5$1 = { class: "vc-gradient-picker__body" };
const _hoisted_6$1 = {
  class: "vc-color-range",
  ref: "colorRangeRef"
};
const _hoisted_7 = { class: "vc-color-range__container" };
const _hoisted_8 = { class: "vc-gradient__stop__container" };
const _hoisted_9 = ["title"];
const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
const _hoisted_11 = [
  _hoisted_10
];
const _hoisted_12 = ["title"];
const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
const _hoisted_14 = [
  _hoisted_13
];
const _hoisted_15 = { class: "vc-picker-degree-input vc-degree-input" };
const _hoisted_16 = { class: "vc-degree-input__control" };
const _hoisted_17 = ["value"];
const _hoisted_18 = { class: "vc-degree-input__panel" };
const _hoisted_19 = { class: "vc-degree-input__disk" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Angle = resolveComponent("Angle");
  const _component_Palette = resolveComponent("Palette");
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Lightness = resolveComponent("Lightness");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    withDirectives(createElementVNode("div", _hoisted_2$1, [
      createElementVNode("span", {
        style: { "cursor": "pointer" },
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
      }, _hoisted_4$1)
    ], 512), [
      [vShow, _ctx.advancePanelShow]
    ]),
    createElementVNode("div", _hoisted_5$1, [
      createElementVNode("div", _hoisted_6$1, [
        createElementVNode("div", _hoisted_7, [
          createElementVNode("div", {
            class: "vc-background",
            style: normalizeStyle(_ctx.gradientBg)
          }, null, 4),
          createElementVNode("div", _hoisted_8, [
            createElementVNode("div", {
              class: normalizeClass([
                "vc-gradient__stop",
                {
                  "vc-gradient__stop--current": _ctx.state.startActive
                }
              ]),
              ref: "startGradientRef",
              title: _ctx.lang === "ZH-cn" ? "\u5F00\u59CB" : "Start",
              style: normalizeStyle({ left: _ctx.getStartColorLeft + "px" })
            }, _hoisted_11, 14, _hoisted_9),
            createElementVNode("div", {
              class: normalizeClass([
                "vc-gradient__stop",
                {
                  "vc-gradient__stop--current": !_ctx.state.startActive
                }
              ]),
              ref: "stopGradientRef",
              title: _ctx.lang === "ZH-cn" ? "\u7ED3\u675F" : "End",
              style: normalizeStyle({ left: _ctx.getEndColorLeft + "px" })
            }, _hoisted_14, 14, _hoisted_12)
          ])
        ])
      ], 512),
      createElementVNode("div", _hoisted_15, [
        createElementVNode("div", _hoisted_16, [
          createElementVNode("input", {
            value: _ctx.state.angle,
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onDegreeBlur && _ctx.onDegreeBlur(...args))
          }, null, 40, _hoisted_17)
        ]),
        createElementVNode("div", _hoisted_18, [
          createElementVNode("div", _hoisted_19, [
            createVNode(_component_Angle, {
              angle: _ctx.state.angle,
              "onUpdate:angle": _cache[2] || (_cache[2] = ($event) => _ctx.state.angle = $event),
              size: 40,
              onChange: _ctx.onDegreeChange
            }, null, 8, ["angle", "onChange"])
          ])
        ])
      ])
    ]),
    !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
      key: 0,
      onChange: _ctx.onCompactChange
    }, null, 8, ["onChange"])) : createCommentVNode("", true),
    _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
      key: 1,
      color: _ctx.currentColor,
      onChange: _ctx.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
      key: 2,
      color: _ctx.currentColor,
      onChange: _ctx.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
      key: 3,
      color: _ctx.currentColor,
      onChange: _ctx.onLightChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
      key: 4,
      color: _ctx.currentColor,
      onChange: _ctx.onAlphaChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    createVNode(_component_Display, {
      color: _ctx.currentColor,
      "disable-alpha": _ctx.disableAlpha
    }, null, 8, ["color", "disable-alpha"]),
    !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
      key: 5,
      round: _ctx.roundHistory,
      colors: _ctx.historyColors,
      onChange: _ctx.onCompactChange
    }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
  ]);
}
var GradientColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-f63daa7a"]]);
var WrapContainer_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1 = defineComponent({
  name: "WrapContainer",
  props: {
    showTab: propTypes.bool.def(false),
    activeKey: propTypes.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(props, { emit }) {
    const state = reactive({
      activeKey: props.activeKey
    });
    const parent = inject(ColorPickerProviderKey);
    const onActiveKeyChange = (key) => {
      state.activeKey = key;
      emit("update:activeKey", key);
      emit("change", key);
    };
    whenever(() => props.activeKey, (value) => {
      state.activeKey = value;
    });
    return { state, onActiveKeyChange, lang: parent == null ? void 0 : parent.lang };
  }
});
const _hoisted_1 = { class: "vc-colorpicker" };
const _hoisted_2 = { class: "vc-colorpicker--container" };
const _hoisted_3 = {
  key: 0,
  class: "vc-colorpicker--tabs"
};
const _hoisted_4 = { class: "vc-colorpicker--tabs__inner" };
const _hoisted_5 = { class: "vc-btn__content" };
const _hoisted_6 = { class: "vc-btn__content" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", _hoisted_2, [
      _ctx.showTab ? (openBlock(), createElementBlock("div", _hoisted_3, [
        createElementVNode("div", _hoisted_4, [
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _ctx.state.activeKey === "pure"
              }
            ]),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onActiveKeyChange("pure"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", _hoisted_5, toDisplayString(_ctx.lang === "ZH-cn" ? "\u7EAF\u8272" : "Pure"), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _ctx.state.activeKey === "gradient"
              }
            ]),
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onActiveKeyChange("gradient"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", _hoisted_6, toDisplayString(_ctx.lang === "ZH-cn" ? "\u6E10\u53D8\u8272" : "Gradient"), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle({
              width: `50%`,
              left: `calc(${_ctx.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])
  ]);
}
var WrapContainer = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-4afdf3bb"]]);
var ColorPicker_vue_vue_type_style_index_0_scoped_true_lang = "";
const colorPickerProps = {
  isWidget: propTypes.bool.def(false),
  pickerType: propTypes.oneOf(["fk", "chrome"]).def("fk"),
  shape: propTypes.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: propTypes.string.def("#000"),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: propTypes.bool.def(false),
  disableHistory: propTypes.bool.def(false),
  roundHistory: propTypes.bool.def(false),
  useType: propTypes.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: propTypes.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: propTypes.number.def(9999)
};
const _sfc_main = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker, ChromeColorPicker, GradientColorPicker, WrapContainer },
  inheritAttrs: false,
  props: colorPickerProps,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(props, { emit }) {
    const state = reactive({
      pureColor: props.pureColor || "",
      activeKey: props.useType === "gradient" ? "gradient" : "pure",
      isAdvanceMode: false
    });
    provide(ColorPickerProviderKey, {
      lang: computed(() => props.lang || "ZH-cn")
    });
    const instance = new Color(state.pureColor);
    const colorInstance = ref(instance);
    const startColor = new Color("#000");
    const endColor = new Color("#000");
    const gradientState = reactive({
      startColor,
      endColor,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      gradientColor: props.gradientColor
    });
    const showPicker = ref(false);
    const colorCubeRef = ref(null);
    const pickerRef = ref(null);
    const getBgColorStyle = computed(() => {
      const bgColor = state.activeKey !== "gradient" ? tinycolor(state.pureColor).toRgbString() : gradientState.gradientColor;
      return {
        background: bgColor
      };
    });
    const getComponentName = computed(() => {
      if (state.activeKey === "gradient") {
        return GradientColorPicker.name;
      }
      return props.pickerType === "fk" ? FkColorPicker.name : ChromeColorPicker.name;
    });
    const getBindArgs = computed(() => {
      if (state.activeKey === "gradient") {
        return {
          startColor: gradientState.startColor,
          endColor: gradientState.endColor,
          onStartColorChange: (v) => {
            gradientState.startColor = v;
            onGradientChange();
          },
          onEndColorChange: (v) => {
            gradientState.endColor = v;
            onGradientChange();
          },
          angle: gradientState.angle,
          startColorStop: gradientState.startColorStop,
          endColorStop: gradientState.endColorStop,
          onStartColorStopChange: (v) => {
            gradientState.startColorStop = v;
            onGradientChange();
          },
          onEndColorStopChange: (v) => {
            gradientState.endColorStop = v;
            onGradientChange();
          },
          onAngleChange: (v) => {
            gradientState.angle = v;
            onGradientChange();
          },
          onAdvanceChange: (v) => {
            state.isAdvanceMode = v;
          }
        };
      }
      return {
        disableAlpha: props.disableAlpha,
        disableHistory: props.disableHistory,
        roundHistory: props.roundHistory,
        color: colorInstance.value,
        onChange: onColorChange,
        onAdvanceChange
      };
    });
    const onAdvanceChange = (isAdvance) => {
      state.isAdvanceMode = isAdvance;
    };
    const onShowPicker = () => {
      showPicker.value = true;
    };
    const onHidePicker = () => {
      showPicker.value = false;
    };
    const parseGradientColor = () => {
      var _a, _b, _c, _d;
      try {
        const [colorNode] = parse(gradientState.gradientColor);
        if (colorNode && colorNode.type === "linear-gradient" && ((_a = colorNode.orientation) == null ? void 0 : _a.type) === "angular" && colorNode.colorStops.length >= 2) {
          const startColorVal = colorNode.colorStops[0];
          const endColorVal = colorNode.colorStops[1];
          gradientState.startColorStop = Number((_b = startColorVal.length) == null ? void 0 : _b.value) || 0;
          gradientState.endColorStop = Number((_c = endColorVal.length) == null ? void 0 : _c.value) || 0;
          gradientState.angle = Number((_d = colorNode.orientation) == null ? void 0 : _d.value) || 0;
          const [r, g, b, a] = startColorVal.value;
          const [r1, g1, b1, a1] = startColorVal.value;
          gradientState.startColor = new Color({
            r: Number(r),
            g: Number(g),
            b: Number(b),
            a: Number(a)
          });
          gradientState.startColor = new Color({
            r: Number(r1),
            g: Number(g1),
            b: Number(b1),
            a: Number(a1)
          });
        }
      } catch (e) {
        console.log(`[Parse Color]: ${e}`);
      }
    };
    const onGradientChange = () => {
      const nodes = color2GradientNode();
      try {
        gradientState.gradientColor = stringify(nodes);
        emit("update:gradientColor", gradientState.gradientColor);
        emit("gradientColorChange", gradientState.gradientColor);
      } catch (e) {
        console.log(e);
      }
    };
    const color2GradientNode = () => {
      const nodes = [];
      const startColorArr = gradientState.startColor.RGB.map((v) => v.toString());
      const endColorArr = gradientState.endColor.RGB.map((v) => v.toString());
      nodes.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: gradientState.angle + "" },
        colorStops: [
          {
            type: "rgba",
            value: [startColorArr[0], startColorArr[1], startColorArr[2], startColorArr[3]],
            length: { value: gradientState.startColorStop + "", type: "%" }
          },
          {
            type: "rgba",
            value: [endColorArr[0], endColorArr[1], endColorArr[2], endColorArr[3]],
            length: { value: gradientState.endColorStop + "", type: "%" }
          }
        ]
      });
      return nodes;
    };
    const onInit = () => {
      if (colorCubeRef.value && pickerRef.value) {
        createPopper(colorCubeRef.value, pickerRef.value, {
          placement: "auto",
          modifiers: [
            {
              name: "flip",
              options: {
                fallbackPlacements: ["top", "left"]
              }
            }
          ]
        });
      }
    };
    const onColorChange = (v) => {
      colorInstance.value = v;
      state.pureColor = v.toString(props.format);
      emitColorChange();
    };
    const emitColorChange = () => {
      emit("update:pureColor", state.pureColor);
      emit("pureColorChange", state.pureColor);
    };
    onClickOutside(pickerRef, () => {
      onHidePicker();
    });
    const onActiveKeyChange = (key) => {
      state.activeKey = key;
      emit("update:activeKey", key);
      emit("activeKeyChange", key);
    };
    tryOnMounted(() => {
      onInit();
      emitColorChange();
      parseGradientColor();
      onGradientChange();
    });
    whenever(() => props.gradientColor, (value) => {
      if (value != gradientState.gradientColor) {
        gradientState.gradientColor = value;
      }
    });
    whenever(() => gradientState.gradientColor, () => {
      parseGradientColor();
    });
    whenever(() => props.activeKey, (value) => {
      state.activeKey = value;
    });
    whenever(() => props.useType, (value) => {
      if (state.activeKey !== "gradient" && value === "gradient") {
        state.activeKey = "gradient";
      } else {
        state.activeKey = "pure";
      }
    });
    whenever(() => props.pureColor, (value) => {
      const equal = tinycolor.equals(value, state.pureColor);
      if (!equal) {
        state.pureColor = value;
        colorInstance.value = new Color(value);
        emitColorChange();
      }
    }, { deep: true });
    return {
      colorCubeRef,
      pickerRef,
      showPicker,
      colorInstance,
      getBgColorStyle,
      onColorChange,
      onShowPicker,
      onActiveKeyChange,
      getComponentName,
      getBindArgs,
      state
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_WrapContainer = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    !_ctx.isWidget ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["vc-color-wrap", "transparent", { round: _ctx.shape === "circle" }]),
      ref: "colorCubeRef"
    }, [
      createElementVNode("div", {
        class: "current-color",
        style: normalizeStyle(_ctx.getBgColorStyle),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onShowPicker && _ctx.onShowPicker(...args))
      }, null, 4)
    ], 2)) : createCommentVNode("", true),
    _ctx.isWidget ? (openBlock(), createBlock(_component_WrapContainer, {
      key: 1,
      "active-key": _ctx.state.activeKey,
      "onUpdate:active-key": _cache[1] || (_cache[1] = ($event) => _ctx.state.activeKey = $event),
      "show-tab": _ctx.useType === "both",
      onChange: _ctx.onActiveKeyChange,
      style: normalizeStyle({ zIndex: _ctx.zIndex })
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
      ]),
      _: 1
    }, 8, ["active-key", "show-tab", "onChange", "style"])) : createCommentVNode("", true),
    !_ctx.isWidget ? (openBlock(), createBlock(Teleport, {
      key: 2,
      to: "body"
    }, [
      withDirectives(createElementVNode("div", {
        ref: "pickerRef",
        style: normalizeStyle({ zIndex: _ctx.zIndex })
      }, [
        _ctx.showPicker ? (openBlock(), createBlock(_component_WrapContainer, {
          key: 0,
          "show-tab": _ctx.useType === "both" && !_ctx.state.isAdvanceMode,
          "active-key": _ctx.state.activeKey,
          "onUpdate:active-key": _cache[2] || (_cache[2] = ($event) => _ctx.state.activeKey = $event),
          onChange: _ctx.onActiveKeyChange
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
          ]),
          _: 1
        }, 8, ["show-tab", "active-key", "onChange"])) : createCommentVNode("", true)
      ], 4), [
        [vShow, _ctx.showPicker]
      ])
    ])) : createCommentVNode("", true)
  ], 64);
}
var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-0aa3a75d"]]);
const Vue3ColorPicker = {
  install: (app) => {
    app.component(ColorPicker.name, ColorPicker);
    app.component("Vue3" + ColorPicker.name, ColorPicker);
  }
};
export { ColorPicker, Vue3ColorPicker as default };
